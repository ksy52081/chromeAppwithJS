1강

JS나 CSS는 그냥 열수 없다.
웹 브라우저에 열려고 시도하면, 그냥 텍스트 자체를 보여줄 뿐 실행해주지는 않는다.

웹 브라우저는 HTML을 실행해주며,
HTML이 js나 CSS를 실행해주는 방식으로 구동된다.
즉 HTML은 접착제이다.

VS CODE에서는 ! + 엔터를 치면
HTML의 기본 포맷을 자동으로 불러온다. (!!!!)

css는 일반적으로 HTML의 Head에서 불러온다.
Link: 를 쳐서 link:css를 선택하면, css를 불러오는 포맷을 자동으로 작성해준다.

반면에 JS는 일반적으로 HTML의 head가 아닌 Body에서 불러온다.


#2.1
Javascirpt에는 type이 있고, 어떻게 쓰일지를 안다.
integer
float 
2+2 를 작성하면, 2는 integer이며, +를 통해 덧셈을 수행할 수 있음을 안다.
1, 2, 3, 3.5는 js가 숫자란걸 알아먹는다. 1, 1.5 등은 값value를 가진다.

But, text는 다르다.
hello 라고 그냥 치면~ 정의되어 있지 않다고 에러를 출력한다.
"hello"라고 작성해야지 이것이 text, 정확히는 string임을 인지한다.
String이란, 처음부터 끝까지 모두 글자로만 이루어진 묶음을 의미한다.

integer / float / string 은 인간 밀접한 데이터타입이다.

#2.2 #2.3
변수는 더 게을러지기 위해서이다.
console.log(5+2);
console.log(5-2);
console.log(5*2);
console.log(5/2);
5대신 6을 넣고 싶을때, 4번을 바꿀 것을 한번에 바꿀 수는 없을까?
variable이 필요한 순간

const : 상수, 바뀌지 않음을 의미함. 계속  유지됨
let : 중간에 변경 가능한 변수
처음에 정의내릴때는 let a = ~ 와 같이 let을 쓰지만,
이후에 a 변수를 변경할 때에는 let을 붙이지 않는다.

만일 const 로 생성한 변수를 이후에 바꾸려고 하면
Uncaught TypeError : Assignment to constant variable
~ constant variable에 새로운 값을 대입할 수 없다고 에러를 출력한다.
즉, 한번 const 로 정의내리면 다시는 업데이트 할 수 없다.

var이라는 과거 명령어가 있었는데, 호이스팅 관련해 문제가 있었다.
https://www.youtube.com/watch?v=61iolhWgQt0
https://www.howdy-mj.me/javascript/var-let-const/

결국 
주로 Const를 쓰고
가끔씩 let을 쓰고
절대로 var는 쓰지 말것.


#2.4 bOOLEAN
const a = true; 가 맞지
const a = "true"; 는 아니다. 

const a = null;
은 false와는 다르다. false는 a의 값이 false인 것이고
null은 정의되어진 변수 a 속에 "값이 없음"으로 채워져 있다.
※null은 절대로 자연적으로 발생하지 않는다
우리가 의도를 가지고 명징하게 "저기엔 아무것도 없다"를 정의해야지만 발생한다.
파이썬에서는 None을 쓴다.

const a ;
원래 변수를 정의하면, 변수를 부를 이름과, 이름에 대응하는 값 value가 있어야 한다.
변수의 이름을 정의했으나, 이름에 대응되는 값이 존재하지 않을 때, undefined인 상태이다.
컴퓨터의 메모리 속에는 존재하지만, 값이 들어가 있지 않다.

#2.5
여러 데이터를 묶어서 보고싶고, 그 중에 원하는 것만 뽑아 보고싶을 때도 있다.
그걸 동시에 수행하기 위해서 array를 사용

#2.6 object
데이터의 정리정돈을 위해서
player에게 해당되는 나이, 이름, 체중 등의 변수를 묶을 수 없을까?

list 로는, [23, "nico", 40, 13] 이 각각 무엇을 의미하는지 알 수 없다.
이 때 필요한 것이 object 대괄호 대신 중괄호, = 대신 : 를 쓴다.
const player = {
    name :"nico",
    age : 23,
    weight : 60
}
쇼핑 리스트와 같은 list는 구성에 잡다한 설명이 필요없다.
하지만 object는 값만으로는 의미가 알 수 없는 property가 있다. ~ {prop : value} 형태를 가진다.

## 이상하다. const는 업데이트가 안되는것 아닌가?
list 나 object 를 const로 소환하더라도
우리가 해왔던 행동들은 list / object 안의 무언가를 수정하는 것이지
object 자체는 여전히 동일하다.
에러는 ~ const 전체를 하나의 값으로서 통째로 무언가 다를것으로 업데이트 하려고 할 때 발생한다.


#2.7 #2.8 Function
function은 네가 계속 반복해서 사용할 수 있는 코드 조각
(우리는 항상 게으르고, 최대한 코드를 적게 쓰고 싶다.)
예를들어, 친구에게 인사하고 싶은데
console.log("hello, kim")
console.log("hello, danis")
console.log("hello, dewitt")
console.log("hello, tony")
... 같은 부분을 반복하는건 비효율적이다.

변수는 const / let을 쓰고,
리스트는 [], 딕셔너리는 {}를 쓰는것처럼
함수도 약속이 있다
function 함수이름(){
    하고싶은일
};
이를 수행하고 싶을 때는
함수이름(); 
을 적어 수행할 수 있다.

argument =function을 실행하는 동안 어떤 정보를 function에게 보낼 수 있는 방법

function sum(a,b){
    console.log(a+b)    
};
sum()을 수행하면,
결과값은 NaN이 출력된다. 이것은
Not a Number의 준말이다.

함수에서 받는 변수는 받는 변수의 순서가 매우 중요하다.

※ 함수 속에서 임의로 불려진 argument 변수들은 내부에서만 통용될 뿐,
함수 밖으로 나갔을 때에는 휘발되어서 존재하지 않는다.



#3.0
devtool console에다 document를 작성하면  html을 보여준다.
(이미 js는 html과 연결되어 있다.)
이처럼 document는 브라우저에 이미 존재하는 object이다. 
누구나 접근할수 있는 html을 가리키는 객체이다./

//console.dir(document)
를 처보면 알 수 있듯, 그냥 하나의 object에 불과하다. 걱정말 것
document.title 로 가보면 html에 설정해둔 Momentum이란 이름이 저장되어 있음을 알 수 있다.
JS에서 title을 정의한 적 없음에도 document가 html을 보여주는것.
※ HTML 코드를 javascript의 관점에서 보고 있다.

//console.dir는 element object의 내부까지 볼 수 있다.

콘솔에서 
document.title = "hi"
를 입력하면
탭에 보여지던 Momentum 타이틀이 hi로 즉시 바뀌는 걸 볼 수 있다.
콘솔에 document를 써서 열었을때 <title> 안에 내용도 hi로 바뀌어있다.
물론 새로고치면 기존의 html에서 가져오므로 title도 원상복귀된다.

#3.1
html에는
<h1 id="title"> grab me! </h1>

console에는
document.getElementById("title")


우리가 하고 있는 것은 html을 수정하고 있지만
그걸 JS에서 확인한다.
JS는 이 html element를 가지고 오지만 html 자체를 보여주지 않는다.

eg: html에 autofocus를 집어넣으면, js 콘솔에서 document.autofocus가 true 를 가진다.


#3.2
html에서, id는 사용하기 편리하지만
보통 class name을 사용하거나 둘 다 사용한다.

그래서 document.getElementById가 아닌
document.getElementByClassName을 사용한다. 출력값은 object 자체가 아닌 array이다.
document.getElementByTagName은 element에 해당하는 것들을 찾아준다.anchor, div, selection, button 과 같은 것을 

Nico가 가장 선호하는 element 찾기 함수는
document.querySelector (여러개가 있으면 첫번째 하나만)
document.querySelectorAll (여러개가 있으면 모두다, array로 가져온다)
이다.
element를 css 방식(css 노테이션으로)으로 검색할 수 있다. 
css selector를 쓴다고 그렇게 명명된거임

// css selector 인 . 을 넣고
// hello라는 classname을 특정지은 다음
// 그 중에서도 그 안에 있는 h1을 요청한다.
// className의 selector .
// id의 selector #


#3.3 Event

const title1_2 = document.querySelector("div.hello:first-child h1:nth-child(2)");
function handleTitleClick(){
    console.log("title1_2 was clicked!");
};
title1_2.addEventListener("click", handleTitleClick);
// 내가 직접 실행 버튼을 누르지 않고, title1_2라는 element에게 click이라는 event가 발생했을 때 handleTitleClick이라는 함수가 실행되었으면 좋겠다.
// addEventListner에서, 수행을 원하는 함수를 입력할 때 절대 괄호()를 넣지 않는다/
//()는 실행버튼이다. 함수에 가야할 함수 이름만 넣고 유저가 특정 대상에 특정 액션을 취할 때만 실행버튼을 대신 눌러주는 방식이다.


//어떤 이벤트 조건을 달 수 있는가 확인하려면
구글에서 h1 html element mdn으로 검색해라 
HTML element와 javascript element는 다르니 요주의 할것(web apis: js관점의 html heading element라는 의미임)
https://developer.mozilla.org/ko/docs/Web/API/HTMLElement
아니면,
console.dir("니가불러온 element : title") 을 출력시키면 나오는 수많은 properties 들중, on으로 시작하는 모든것이 이벤트

보통 이벤트를 설정할 때 
title1_2.addEventListener("click", handleTitleClick);
식으로 작성하지만, 
title1_2.onclick = handleTitleClick
로도 작성 가능하다.


※document.head document.body document.title은 가능하나 (얘네들은 아주 중요해서...)
document.div 같은 건 없다.
불러오고 싶거들랑 querySelector / getElementById 같은 함수를 써야한다.


#3.6 #3.7 #3.8 CSS in javascript
JS를 이용해서, 글자를 한번씩 클릭할때마다 바탕화면이 파란색 -> 주황색 -> 파란색 -> 주황색으로 전환 되면 좋겠어

#####################
const h1 = document.querySelector("div.hello:first-child h1:first-child");
function handleTitleClick(){
    console.log(h1.style.color);
    h1.style.color="blue";
    console.log(h1.style.color);
}
h1.addEventListener("click", handleTitleClick);
###################
이러면 결과는
''''''''''''''''''
(출력안됨)
blue
'''''''''''''''''
가 나온다.

원하는 액션을 취하려면 아래와 같이 작성해야 한다
####################
const h1 = document.querySelector("div.hello:first-child h1:first-child");
function handleTitleClick(){
    // console.log(h1.style.color);
    // h1.style.color="blue";
    // console.log(h1.style.color);
    const currentcolor = h1.style.color;
    let newColor; //아무것도 안들어있고, 업데이트 가능한 변수생성
    if(currentcolor==="blue"){
        newColor= "tomato"
    }else{
        newColor="blue"
    }
    h1.style.color = newColor; 
}
h1.addEventListener("click", handleTitleClick);
###################
// element의 style을 js에서 변경하는걸 선호하지 않는다(다른 언어를 섞으면 귀찮아질 수도 있다 )
이미지와 디자인의 변형에 대한 내용은 css 파일에서 css의 문법으로 하는것이 바람직하다

#3.7
css파일에서 .~~~~~ 와 같은 새로운 클래스를 생성해 변경점을 반영하고
JS 파일에서 변경하고 싶은 element의 className을 .~~~~~로 변경함으로써 문제를 해결한다.

##########app.js#########
const h1 = document.querySelector("div.hello:first-child h1:first-child");
function handleTitleClick(){
    const clickedClass = "click_turnOn"
    if (h1.className===clickedClass){
        h1.className = "";
    }else{
        h1.className = clickedClass;
        // h1.className은 getter 이자 setter 이므로, 조건문에서 ===로 get 할수도, 함수에서 =로 set 할수도 있다.
    }
}
###################

#########style.css##########
.click_turnOn{
    color : tomato;
    transition: color .5s ease-in-out;
    /* 천천히 색변환 */
}
###################\

하지만 이런 방식은 심각한 오류를 야기한다.
변경하고자 하는 element가 기존에 어떤 className을 가지고 있던
js 함수를 거치면 이전의 className은 깡그리 잊어버리고 무조건 정해진대로 바뀐다.
되돌리려 해도 잊어버린 className을 기억할 방법이 없는 문제가 있다.
-> 그렇다면 수행 했다가 "되돌리는" 방법은 없을까? ->#3.8

#3.8 
classList를 사용하면 기억하고 되둘리는 것이 가능하다.
classList를 사용해 classlist.add 를 사용해 새로운 class를 추가하면
<h1 class = "originalClass addedClass"> ~~~ </h1> 
꼴을 만들 수 있다.
아래와 같이 작성한다 

####################
const h1 = document.querySelector("div.hello:first-child h1:first-child");
function handleTitleClick(){
    const clickedClass = "click_turnOn"
    if (h1.classList.contains(clickedClass)){
        h1.classList.remove(clickedClass); //h1.className = ""; 대신
    }else{
        h1.classList.add(clickedClass);    //h1.className = clickedClass; 대신
        // h1.className은 getter 이자 setter 이므로, 조건문에서 ===로 get 할수도, 함수에서 =로 set 할수도 있다.
    }
}
####################

classlist 에 add remove를 수행하는게 원채 잦다보니 이 행동 자체를 함수로 만들었다.



class 혹은 id를 써서 구분을 시키되, 중복이 없도록 조심할 것
아래의 두 코드는 같은 의미이다. 
// const loginform = document.querySelector("#login-form");
// const loginInput = loginform.querySelector("input");

//const loginInput = document.querySelector("#login-from input");


input 칸에 입력할 수 있는 내용의 적합성 평가 (빈칸 안됨, 너무 길면 안됨 등등...)
을 js를 이용해 아래 처럼 작성할 수 있으나
###################
const loginInput = document.querySelector("#login-from input");
const loginButton = document.querySelector("#login-from button");

function onLoginBtnClick(){
    // console.dir(loginInput);
    const username = loginInput.value;
    if (username === ""){
        alert("Plz write your name");
    } else if (username.length > 15){
        alert("your name is too long");

    }
    console.log("clicked!")
}
loginButton.addEventListener("click", onLoginBtnClick);
##################

html의 고유 기능에도 적합성 평가를 넣을 수 있다.

<form> element,
<input> element 속 required 를 사용하면
굳이 js에서 적합성 조건과, 그 경우 어떤 메세지를 보낼지 일일이 정하지 않더라도
html 선에서 "입력란에 입력하세요" 메세지가 뜬다.

JS까지 갈 필요 없이 HTML 안에서 
<form> element 안에 있는 버튼을 누르거나
<input type="submit" value="~~~" /> 처럼 type="submit" 을 넣을경우
클릭과 동시에 submit이 이루어진다.
엔터를 누르고, input이 더이상 존재하지 않는다면 submit이 된다.
하지만 submit이 가동되면 웹사이트가 자동으로 새로고침을 수행한다 ㄷㄷ
form 의 submit에서 새로고침은 default 기본동작이다.

login 버튼을 클릭하면 submit  하는 기능도 html에서 구현되므로,
JS에서 loginBtn 과, 클릭시 작용하는 액션 등을 정의할 필요도 없어진다.

##########################
const link = document.querySelector("a");

function handleLinkClick(event){
    event.preventDefault();
    console.dir(event)
    // alert("clicked")
    // 앞서 이야기했듯, alert가 가동되면 alert가 종료되기 전까지 모든 행동이 멈춘다.
}

link.addEventListener("click", handleLinkClick)
##########################

//////////////////// 중요 ////////////////////////////////////////

function onLoginSubmit(event){
event.preventDefault(); // 브라우저가 기본 동작을 실행하지 못하게 막기 // event object는 preventDefault함수를 기본적으로 갖고 있음
console.log(event);
}

loginForm.addEventListener("submit", onLoginSubmit); // submit 이벤트가 발생한다면, onLoginSubmit함수를 실행시킨다는 의미 // JS는 onLoginSubmit함수 호출시 인자를 담아서 호출함. 해당 인자는 event object를 담은 정보들
addEventListener 속에 입력된 함수는 우리가 가동시키는게 아니라
addEventListner가 "방금 일어난 이벤트에 대한 정보"를 변수로 넣고
onLoginSubmit({information about the event that just happened})
처럼 가동되는 것이다.

★ 중요 ★
form을 submit하면 브라우저는 기본적으로 페이지를 새로고침 하도록 되어있다. << 우리가 원하는 것이 아님!
preventDefault() 함수를 추가함으로써 브라우저의 기본 동작을 막을 수 있다!!

이 preventDefault 함수는 EventListener 함수의 '첫 번째 argument' 안에 있는 함수이다. 첫 arument는 지금 막 벌어진 event들에 대한 정보를 갖고 있다.
JS는(기본적으로)argument를 담아서 함수를 호출하는데, 이 argument가 기본 정보들을 제공하고 있다. ex) 누가 submit주체인지, 몇 시에 submit을 했는지 등등 콘솔에 출력해보면 알 수 있음


////////////////////////////////////////////////////////////


#4.4 
어떤 액션 이후에 레이아웃이 사라지는 방법
option 1) HTML 요소 자체를 제거하는 방법
option 2) css를 이용해 숨기는 방법

.hidden{
    display: none;
}

 비어있는 곳에 원하는 글자를 집어넣을때
const greeting = document.querySelector("#greeting");
greeting.innerText = "Hello" + username

※ 일반적으로 string만 포함한 변수는 대문자로 표기하고, String을 저장하고 싶을때 사용한다.
eg ~ const HIDDEN_CLASSNAME = "hidden"

※ 아래 두 코드는 출력 값이 같다
const username = loginInput.Value;
greeting.innerText = "Hello" + username;
greeting.innerText = `Hello ${username}`;
중요한 규칙 두가지
1) 원하는 입력값의 주위에 ${} 로 감싼다.
2) ""(Double quoto) 나 ''(single quoto) 이 아닌 ``(Backtick)을 써야한다.

#4.5
이미 볼륨을 기억하는 등 기억하기 기능은 흔히들 늘상 있어왔다.
사용하는 API 는 local starage이다.
이미 존재하며, 우리가 브라우저에 뭔가를 저장할 수 있게 해준다.~ 나중에 가져다 쓸 수 있게 해준다.

위치 : devtools > application > LNB 쪽에 Local Storage가 있음 
https://developer.mozilla.org/ko/docs/Web/API/Window/localStorage
localStorage.setItem("username", "syKim");
localStorage.getItem("username")
localStorage.removeItem("username")

#4.6 
한번 localStorage에 데이터를 저장했으면,
다음번 새로고침때 이미 localStorage에 데이터 존재 여부를 확인하고
있을 경우에는 로그인/유저네임 추가하기 버튼을 보이지 않고
바로 greeting 레이아웃을 보여줬으면 좋겠다.

그렇다면 기본적으로
모든 레이아웃을 숨겨놓고
localStorage에 저장되어 있지 않다면 loginform을
localStorage에 저장되어 있다면 greeting을 보여준다.(hidden을 없앰)

#5.0
시간 관련된 함수
interval : 매 순간 주기적으로 해야하는것, 매2초
서버를 확인하거나 주식시장 api를 확인하거나 
setinterval(함수, 5000); //0초에 한번 보여주고 5초뒤가 아닌, 5초 기다렸다가 이후에 출력하기 시작함.
//즉, 아무리 setinterval을 쓴다 하더라도, 새로고침하자마자 한번 보여주고 시작하려면
//앞에 한번 출력해주고 interval을 수행해야함.
timeout(함수, 1000);

Date 함수
https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Date
const date = new Date()

date.getDate() //~일
date.getDay() //일월화~금토일
.getHours
getMinutes
getseconds
※ 출력되는 결과값은 String이 아닌 integer이다.

지금은 19:22:01 이 아니라
19:22:1 꼴로 나오는 상태이다.
이를 고치려면 ~ #5.2

#5.2 
clock.innerText =`${date.getHours()}:${date.getMinutes()}:${date.getSeconds()}`
꼴은
9:11:1 과 같은 결과가 출력된다
우리는 
09:11:01 과 같은 형태로 출력되길 바란다.
그 때 사용하는 함수는 character.padStart(length, character); 이다.
글자 변수에 내장되어 있는 함수이며

"1".padStart(2,"0") 을 입력하면
"01"을 출력한다.

"1".padEnd(2,"0") 을 입력하면
"10"을 출력한다.


#6.0 
Math 
Math.random

Math.round() 반올림
Meth.ceil() 올림
Math.floor() 내림


#6.3
여태까지는 js를 이용해서 뭔가를 가져왔다. <div> 든 <span> 이든..
항상 html에서 먼저 작성하고, js를 사용해 이미 있는 html을 수정변경하는 방식으로 
진행해왔다.

우리가 직접 js에서 뭔가 만들어서 html에 추가해본적은 없다.

우리의 최종 목표는
js를 활용해서
<img src="img/0.jpg" /> 를 작성해 html에 원하는 장소에 붙이는 것이다.

document.createElement("img") 함수로
원하는 탭을 생성한다.

document.body.appendChild()
는 body 속 맨 뒤의 위치에 새로운 element를 추가하는 함수이다.


Q1. appendChild를 사용할 때 body에 넣고 싶은 위치에 정확히 넣으려면 어떻게 하나요?
영상에서만 봤을 때는 맨 마지막에 들어가는 것 같은데, 중간에 태그를 넣고싶은 경우는 어떻게 하나요?

A1. insertBefore() 메소드를 사용하시면 됩니다
이 메소드는 참조된 노드 앞에 특정 부모 노드의 자식 노드를 삽입합니다.
const h2 = document.querySelector("#clock")
document.body.insertBefore(bgImage, h2);
두개의 인자중에 앞의 bgImage는 새로운 노드 즉 추가하고 싶은 노드이고 h2는 참조할 노드입니다. 즉 이렇게 코드를 짜시면 h2요소 앞에 bgImage가 추가되게 됩니다.

Q2 사진을 배경 이미지로 넣고 싶다면?

A2. 
사진을 배경이미지로 넣고 싶다면
img {
position:absolute;
width:100%;
height:100%;
left: 0px;
top: 0px;
right:0px;
bottom:0px;
z-index: -1;
opacity:80%;
}
설정 하시면 됩니다. opacity는 취향대로 하시면 되고 z-index는 text의 z-index 보다 낮으면 뒷 배경으로 설정 됩니다.

Q3. background img를 가져와서 붙이긴 했지만, 여느 졸업 작품들 처럼 full-screen이면서 website 창의 크기에 맞춰 flexible 하는 방법이 궁금해졌습니다.

A3. 과정
일단 background.js 에서 수정할 방법을 찾다가 안될 것 같아 css에서 다루기게 맞다고 생각함.
다만, background.js에서 createElement로 html에 새로만든 img라는 것이 class인지 id인지 확정되지 않아서인지 '.img', '#img'로도 style변경이 안됨.

~~~해결방법
여러 가지로 찾던 중 단순히 img를 css로 변경할 것이 아니라 html body자체를 변경해주는 것이 맞는걸 찾음.
공부하는 사람 중에 저처럼 img를 full-screen, non-fixed로 하고싶으신 분들은 아래 코드를 css에 작성해보세요~
적어도 저는 해결했습니다~
body{
background-position: center center;
background-size: cover;
background-repeat: no-repeat;
background-attachment: fixed;
}


